function ad2ansys(maptype,nlistfile,forcesfile,outfile)
%AD2ANSYS  Maps AeroDyn forces to an ANSYS blade FE model
% **********************************************************************
% *                   Part of the SNL NuMAD Toolbox                    *
% * Developed by Sandia National Laboratories Wind Energy Technologies *
% *             See license.txt for disclaimer information             *
% **********************************************************************
%   ad2ansys(maptype,nlistfile,forcesfile,outfile)
%
%   Note: you may omit any or all of the filename arguments and the script
%         will provide a file selection box.
%
%     maptype = 'map2D_fxM0' Maintains Fx, Fy, and Mz
%                            fx forces produce zero Mz moment
%               'map3D_fxM0' (default) Maintains Fx, Fy, Mz, and root moments
%                            fx forces produce zero Mz moment
%
%     nlistfile  = name of Node List file generated by ANSYS
%
%     forcesfile = name of file containing the load definition with
%     columns:
%       Z  - spanwise location of forces (center of aero element)
%       Fx - forces aligned with the X axis of the ANSYS blade model
%       Fy - forces aligned with the Y axis of the ANSYS blade model
%       M  - moments about Z axis
%       Alpha - CURRENTLY UNUSED
%       x_off -
%       y_off -
%
%     outfile = name of the output file to be /INPUT in ANSYS

% set the default mapping algorithm
if ~exist('maptype','var') || isempty(maptype)
    maptype = 'map3D_fxM0';
end

% open file selector if 'nlistfile' not given
if ~exist('nlistfile','var') || isempty(nlistfile)
    [fn,pn] = uigetfile( ...
        {'*.lis','ANSYS node list (*.lis)'; ...
        '*.*','All files (*.*)'},...
        'Select the ANSYS node list');
    if isequal(fn,0) || isequal(pn,0)
        disp('Operation canceled by user.')
        return;
    end
    nlistfile = fullfile(pn,fn);
    nlistpath = pn;
end
% read the node list file
nlist = read_nlist(nlistfile);
%     assignin('base','nlist',nlist);  %debugging


% open file selector if 'forcesfile' not given
if ~exist('forcesfile','var') || isempty(forcesfile)
    [fn,pn] = uigetfile( ...
        {'*.forces','AD line load (*.forces)'; ...
        '*.*','All files (*.*)'},...
        'Select the forces file');
    if isequal(fn,0) || isequal(pn,0)
        disp('Operation canceled by user.')
        return;
    end
    forcesfile = fullfile(pn,fn);
end
% read the forces file
forces = read_forces(forcesfile);
%     assignin('base','forces',forces);  %debugging
if isempty(forces{1})
    error('The forces file "%s" is not formatted correctly.  Please ensure there are seven columns and one header line.',forcesfile);
end

switch maptype
    case 'map2D_fxM0'
        forcemap = map2D_fxM0(nlist,forces);
    case 'map3D_fxM0'
        forcemap = map3D_fxM0(nlist,forces);
end

forcesums = check_sums(nlist,forces,forcemap);

% open file selector if 'outfile' not given
if ~exist('outfile','var') || isempty(outfile)
    outfile = fullfile(nlistpath,'forces.src');
    [fn,pn] = uiputfile( ...
        {'*.*', 'All files (*.*)'},...
        'Save Output As',outfile);
    if isequal(fn,0)
        % the user canceled file selection
        return
    end
    outfile = fullfile(pn,fn);
end

% write the ansys commands which apply the calculated forces
writeforcefile(outfile,forcemap,forcesums,maptype);

% plot the results
if (1)
    figure(1007);
    subplot(2,2,[1,3])
    ds = ceil(size(nlist,1)/1e3); % downsample to 1000 points
    k = 1:ds:size(nlist,1);
    quiver3(nlist(k,2),nlist(k,3),nlist(k,4),...
        forcemap.fx(k), forcemap.fy(k), zeros(size(forcemap.fx(k))));
    title('Force vectors visual check (downsampled)');
    axis equal;
    subplot(2,2,2)
    [~,k] = sort(nlist(:,4));  % sort order, sorting on Z
    plot(nlist(k,4),forcemap.fx(k),'.');
    xlabel('z'); ylabel('fx')
    subplot(2,2,4)
    plot(nlist(k,4),forcemap.fy(k),'.');
    xlabel('z'); ylabel('fy')
end
end

function nlist = read_nlist(filename)
if ~exist('filename','var')
    filename = 'NLIST.lis';
end

% Open the file and read the entire contents
fid = fopen(filename);
if (fid == -1)
    error('Could not open file "%s"',filename);
end
filecontents = fread(fid,inf,'uint8=>char')';
fclose(fid);

nlist = cell(1,4);
tbl_hdrs = regexp(filecontents,'NODE\s*X\s*Y\s*Z\s*');
for kTbl = 1:numel(tbl_hdrs)-1
    tbl = filecontents(tbl_hdrs(kTbl):tbl_hdrs(kTbl+1)-1);  % grab table
    data = regexprep(tbl,'\s*NODE\s*X\s*Y\s*Z\s*','');  % remove header
    nlist = [nlist; textscan(data,'%f %f %f %f')];  %#ok (growing data)
end

% get the last table
kTbl=0;  %brr  updated for new make_nlist macro with huges "pages"
tbl = filecontents(tbl_hdrs(kTbl+1):end);  % grab table
data = regexprep(tbl,'\s*NODE\s*X\s*Y\s*Z\s*','');  % remove header
nlist = [nlist; textscan(data,'%f %f %f %f')];

nlist = cell2mat(nlist);
end

function forces = read_forces(filename)

% Open the file
fid = fopen(filename);
if (fid == -1)
    error('Could not open file "%s"',filename);
end
header = fgetl(fid);  %#ok (header not used)
filecontents = fread(fid,inf,'uint8=>char')';
fclose(fid);

% 'Z (m)	Fx (N)	Fy (N)	M (N-m)	Alpha	x_off	y_off'
forces = textscan(filecontents,repmat('%f',1,7));
end

function forcemap = map2D_fxM0(nlist,forces)
% Map forces such that the equivalent Fx Fy and M are maintained for each
% section.  It is assumed that only the fy forces contribute to M and fx
% are balanced to produce no moment.
mesh.n = nlist(:,1);
mesh.x = nlist(:,2);
mesh.y = nlist(:,3);
mesh.z = nlist(:,4);

aero.Z = forces{1};
aero.Fx = forces{2};
aero.Fy = forces{3};
aero.M = forces{4};
aero.alpha = forces{5};
aero.xoff = forces{6};
aero.yoff = forces{7};

% divide nodes into spanwise groups
bin = zeros(size(mesh.n));  % each FEA node will be assigned to a bin
for nk = 1:length(mesh.n)
    halfDZ = aero.Z(1);  % initialize section width
    for bk = 1:numel(aero.Z);
        OBedge = aero.Z(bk) + halfDZ;  % outboard edge of section
        if (mesh.z(nk) <= OBedge) || (bk==numel(aero.Z));
            bin(nk) = bk;
            break
        end
        halfDZ = aero.Z(bk+1) - OBedge;
    end
end

forcemap.n = nlist(:,1);
forcemap.bin = bin;
forcemap.fx = zeros(size(mesh.n));
forcemap.fy = zeros(size(mesh.n));
for bk = 1:length(aero.Fx)
    i = find(bin==bk);
    N = length(i);
    x = mesh.x(i)-aero.xoff(bk);
    y = mesh.y(i)-aero.yoff(bk);
    mx = mean(x);
    my = mean(y);
    mxx = mean(x.^2);
    myy = mean(y.^2);
    %mxy = mean(x.*y);
    A = [my,   1,  0,   0;
        0,    0,  mx,  1;
        0     0,  mxx, mx;
        -myy, -my, 0,   0];
    F = 1/N * [aero.Fx(bk); aero.Fy(bk); aero.M(bk); 0];
    ab = A\F;
    forcemap.fx(i) = ab(1)*y + ab(2);
    forcemap.fy(i) = ab(3)*x + ab(4);
end
end


function forcemap = map3D_fxM0(nlist,forces)
% Map forces such that the equivalent Fx Fy and M are maintained for each
% section.  It is assumed that only the fy forces contribute to M and fx
% are balanced to produce no moment.
mesh.n = nlist(:,1);
mesh.x = nlist(:,2);
mesh.y = nlist(:,3);
mesh.z = nlist(:,4);

aero.Z = forces{1};
aero.Fx = forces{2};
aero.Fy = forces{3};
aero.M = forces{4};
aero.alpha = forces{5};
aero.xoff = forces{6};
aero.yoff = forces{7};

% divide nodes into spanwise groups
bin = zeros(size(mesh.n));  % each FEA node will be assigned to a bin
for nk = 1:length(mesh.n)
    halfDZ = aero.Z(1);  % initialize section width
    for bk = 1:numel(aero.Z);
        OBedge = aero.Z(bk) + halfDZ;  % outboard edge of section
        if (mesh.z(nk) <= OBedge) || (bk==numel(aero.Z));
            bin(nk) = bk;
            break
        end
        halfDZ = aero.Z(bk+1) - OBedge;
    end
end

forcemap.n = nlist(:,1);
forcemap.bin = bin;
forcemap.fx = zeros(size(mesh.n));
forcemap.fy = zeros(size(mesh.n));
for bk = 1:length(aero.Fx)
    i = find(bin==bk);
    N = length(i);
    x = mesh.x(i)-aero.xoff(bk);
    y = mesh.y(i)-aero.yoff(bk);
    z = mesh.z(i);
    mx = mean(x);
    my = mean(y);
    mz = mean(z);
    mxx = mean(x.^2);
    myy = mean(y.^2);
    mzz = mean(z.^2);
    %mxy = mean(x.*y);
    mzx = mean(z.*x);
    mzy = mean(z.*y);
    A = [mz,   my,   1,   0,   0,   0;
        0,    0,    0,   mz,  mx,  1;
        0,    0,    0,   mzx, mxx, mx;
        -mzy, -myy, -my,  0,   0,   0;
        0,    0,    0,   mzz, mzx, mz;
        mzz,  mzy,  mz,  0,   0,   0];
    F = 1/N * [aero.Fx(bk); aero.Fy(bk); aero.M(bk); 0; ...
        aero.Z(bk)*aero.Fy(bk); aero.Z(bk)*aero.Fx(bk)];
    abc = A\F;
    forcemap.fx(i) = abc(1)*z + abc(2)*y + abc(3);
    forcemap.fy(i) = abc(4)*z + abc(5)*x + abc(6);
end
end


function forcesums = check_sums(nlist,forces,forcemap)
aero.Z = forces{1};
aero.Fx = forces{2};
aero.Fy = forces{3};
aero.M = forces{4};
aero.alpha = forces{5};
aero.xoff = forces{6};
aero.yoff = forces{7};

forcesums.Z = aero.Z;
forcesums.Fx(:,1) = aero.Fx;
forcesums.Fy(:,1) = aero.Fy;
forcesums.M(:,1) = aero.M;
forcesums.RootMx(:,1) = aero.Z .* aero.Fy;
forcesums.RootMy(:,1) = aero.Z .* aero.Fx;

for bk = 1:length(aero.Fx)
    i = find(forcemap.bin==bk);
    x = nlist(i,2)-aero.xoff(bk);
    y = nlist(i,3)-aero.yoff(bk);
    z = nlist(i,4);
    forcesums.Fx(bk,2) = sum(forcemap.fx(i));
    forcesums.Fy(bk,2) = sum(forcemap.fy(i));
    forcesums.M(bk,2) = sum(-y.*forcemap.fx(i) + x.*forcemap.fy(i));
    forcesums.RootMx(bk,2) = sum(z.*forcemap.fy(i));
    forcesums.RootMy(bk,2) = sum(z.*forcemap.fx(i));
end

end


function writeforcefile(filename,forcemap,forcesums,maptype)
fid = fopen(filename,'wt');
if (fid == -1)
    error('Could not open file "%s"',filename);
end

if exist('forcesums','var')
    fprintf(fid,'!========== FORCE MAPPING SUMMARY ==========');
    fprintf(fid,'\n!maptype = "%s"',maptype);
    
    s = sprintf('\n!                Z =%s      TOTAL     ',sprintf('  %14.6e',forcesums.Z));
    fprintf(fid,'%s',s);
    fprintf(fid,'\n!%s',repmat('-',1,length(s)));
    
    fprintf(fid,'\n!Input          Fx =');
    fprintf(fid,'  %14.6e',forcesums.Fx(:,1));
    fprintf(fid,'  %14.6e',sum(forcesums.Fx(:,1)));
    fprintf(fid,'\n!Output    sum(fx) =');
    fprintf(fid,'  %14.6e',forcesums.Fx(:,2));
    fprintf(fid,'  %14.6e',sum(forcesums.Fx(:,2)));
    
    fprintf(fid,'\n!%s',repmat('-',1,length(s)));
    
    fprintf(fid,'\n!Input          Fy =');
    fprintf(fid,'  %14.6e',forcesums.Fy(:,1));
    fprintf(fid,'  %14.6e',sum(forcesums.Fy(:,1)));
    fprintf(fid,'\n!Output    sum(fy) =');
    fprintf(fid,'  %14.6e',forcesums.Fy(:,2));
    fprintf(fid,'  %14.6e',sum(forcesums.Fy(:,2)));
    
    fprintf(fid,'\n!%s',repmat('-',1,length(s)));
    
    fprintf(fid,'\n!Input           M =');
    fprintf(fid,'  %14.6e',forcesums.M(:,1));
    fprintf(fid,'  %14.6e',sum(forcesums.M(:,1)));
    fprintf(fid,'\n!sum(-y*fx + x*fy) =');
    fprintf(fid,'  %14.6e',forcesums.M(:,2));
    fprintf(fid,'  %14.6e',sum(forcesums.M(:,2)));
    
    fprintf(fid,'\n!%s',repmat('-',1,length(s)));
    
    fprintf(fid,'\n!Input        Z*Fy =');
    fprintf(fid,'  %14.6e',forcesums.RootMx(:,1));
    fprintf(fid,'  %14.6e',sum(forcesums.RootMx(:,1)));
    fprintf(fid,'\n!Output  sum(z*fy) =');
    fprintf(fid,'  %14.6e',forcesums.RootMx(:,2));
    fprintf(fid,'  %14.6e',sum(forcesums.RootMx(:,2)));
    
    fprintf(fid,'\n!%s',repmat('-',1,length(s)));
    
    fprintf(fid,'\n!Input        Z*Fx =');
    fprintf(fid,'  %14.6e',forcesums.RootMy(:,1));
    fprintf(fid,'  %14.6e',sum(forcesums.RootMy(:,1)));
    fprintf(fid,'\n!Output  sum(z*fx) =');
    fprintf(fid,'  %14.6e',forcesums.RootMy(:,2));
    fprintf(fid,'  %14.6e',sum(forcesums.RootMy(:,2)));
    
    fprintf(fid,'\n\n');
end


fprintf(fid,'finish\n/prep7\n\n');
for nk = 1:length(forcemap.n)
    if forcemap.fx(nk)  % if not zero
        fprintf(fid,'f,%d,fx,%g\n',forcemap.n(nk),forcemap.fx(nk));
    end
    if forcemap.fy(nk)  % if not zero
        fprintf(fid,'f,%d,fy,%g\n',forcemap.n(nk),forcemap.fy(nk));
    end
end

fclose(fid);
end
